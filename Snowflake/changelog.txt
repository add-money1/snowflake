	
	
	2016.05.19
	
		snowflake.core.manager.ChunkManager
			-> "void addAvailableChunks(ArrayList<Chunk>)" and "void addAvailableChunk(Chunk)"
				now check for nullness and validity
			-> "void addAvailableChunk(Chunk)" now removes more chunks if necessary
			
		snowflake.core.manager.ChunkMergingManager
			-> "Chunk getChunk(long minimum_length)" now works different
	
	
	
	2016.05.16
	
		snowflake.core.flake.FlakeDataManager
			-> removed "boolean is_length_changed"
			-> "long getLength()" now only returns the length
			-> every method must calculate for itself the change of length of the flake
				modified:
					"void addChunks(Collection<Chunk>)"
					"void recycle()"
			-> removed "synchronized void countLength()"
			-> removed unnecessary elses in "IChunk getChunkAtPosition(long)", "void arrangeChunks()", and,
				"IChunk getChunkAtPositionBinarySearch(long)"
				
		snowflake.core.DataTable
			-> removed unnecessary else in "long getAvailableIndex()"
			-> additional check for "available_index_tree.add(Long)" in "void addAvailableIndex(long)"
			
		snowflake.core.manager.ChunkManager
			-> removed "Chunk getAvailableChunk(long)"
			-> removed nonsense in "void createAvailableChunk(long)"
	
	
	2016.05.08
		
		snowflake.core.manager.ChunkMergingManager
			-> implemented "boolean addAll(Collection<? extends Chunk>)"
	
	
	
	2016.05.07
	
		snowflake.core.manager.ChunkManager
			-> "void addAvailableChunks(ArrayList<Chunk>)" now adds all chunks at ones to the tree
				with "addAll(Collection<T>" in "j3l.util.BinaryTree" and also uses "addAll(Collection<Chunk>)"
				in "snowflake.core.manager.ChunkMergingManager"
			-> deleted unnecessary else in "void deleteChunk(Chunk)"
		
		snowflake.core.manager.ChunkMergingManager
			-> removed unnecessary else in "boolean add(Chunk)"
	
	
	2016.05.06
	
		snowflake.core.Channel
			-> added check for openness of the data_file (its channel) in 
			"int read(DataPointer, byte[], int, int) throws IOException"
			"int read(DataPointer) throws IOException"
			"void write(DataPointer, byte[], int, int) throws IOException"
			"void write(DataPointer, byte) throws IOException"
			-> modified debug-information in "synchronized void close() throws IOException"
			
		snowflake.core.flake.IRemoveStream
			-> deleted interface
			
		snowflake.core.flake.FlakeStreamManager
			-> deleted class
			
		snowflake.api.FlakeInputStream
			-> removed "remove_stream"
			
		snowflake.api.FlakeOutputStream
			-> removed "remove_stream"
			
		snowflake.core.manager.IManageChannel
			-> changed name to "IChannelManager"
			
		snowflake.core.flake.Flake
			-> changed "void setFlakeStreamManager(FlakeStreamManager)" to
				"void setChannelManager(IChannelManager)"
			-> removed "FlakeStreamManager flake_stream_manager"
			-> modified "FlakeInputStream getFlakeInputStream() throws IOException",
				"FlakeOutputStream getFlakeOutputStream() throws IOException", and
				"void close()" due to the deletion of "snowflake.core.flake.FlakeStreamManager"
			-> no longer implements "boolean isWriting()"
			-> removed "void addChunks(Chunk[])" (not used)
			-> removed "void addChunk(Chunk)" (not used)
			
		snowflake.api.IFlake
			-> removed "boolean isWriting()"
				
		snowflake.core.flake.FlakeDataManager
			-> removed "Object chunk_lock" and replaced its occurences with "ArrayList<Chunk> chunk_list"
			-> removed "void addChunks(Chunk[])" (not used)
			-> removed "void addChunk(Chunk)" (not used)
			
		snowflake.core.manager.FlakeManager
			-> modified "IFlake createFlake(ChunkManager)" and
				"IFlake declareFlake(long, ChunkManager, ArrayList<Chunk>)" due to the deletion of
				"snowflake.core.flake.FlakeStreamManager"
	
		
	2016.05.04
	
		snowflake.api.DataTable
			-> minor changes in "void addEntry(TableMember<T>)" and "long getAvailableIndex()"
			-> moved class to "snowflake.core"
			
		snowflake.api.IBinaryData
			-> moved interface to "snowflake.core"
			
		snowflake.api.TableMember
			-> modified "boolean equals(Object)" so that it is null-safe
			-> moved class to "snowflake.core"
			
		snowflake.api.GlobalString
			-> moved class to "snwoflake.core"
			
		snowflake.api.FlakeOutputStream
			-> changed "IRemoveStream flake_stream_manager" to "IRemoveStream remove_stream"
			-> minor changes in code-format (got rid of unnecessary "else")
			
		snowflake.api.FlakeInputStream
			-> changed "IRemoveStream flake_stream_manager" to "IRemoveStream remove_stream"
			-> minor changes in code-format
			-> modified "synchronized void reset() throws IOException" so that it checks if the stream
				is closed
	
		
	
	2016.05.03
	
		snwoflake.api.chunk.IChunkInformation
			-> moved interface to "snwoflake.core"
			-> changed the name to "IChunk"
	
		snowflake.api.chunk.IChunkManager
			-> removed "Chunk mergeChunks(Chunk[])"
			-> moved the interface to "snowflake.core.manager"
			
		snowflake.core.manager.ChunkManager
			-> removed implementation of "Chunk mergeChunks(Chunk[])"
			
		snowflake.core.flake.FlakeDataManager
			-> removed "void mergeChunks()"
			-> removed "boolean needsChunkMerging()"
			
		snwoflake.core.flake.Flake
			-> removed implementation of "void mergeChunks()"
			-> removed "boolean is_chunk_merging"
			-> removed implementation of "boolean needsChunkMerging()"
			-> removed implementation of "boolean isChunkMerging()"
			-> removed "FlakeLockManager flake_lock_manager"s
			-> modified "synchronized boolean delete()" so that it no longer uses a Lock
			-> replaced "isStreamable()" in "FlakeInputStream getFlakeInputStream() throws IOException"
				for "isVaild()"
			-> replaced "isStreamable()" in "FlakeOutputStream getFlakeOutputStream() throws IOException"
				for "isVaild()" and changed format of code
			-> removed implementation of "boolean isLocked()"
			-> removed implementation of "Lock lock(Object)"
			
		snowflake.api.flake.IFlake
			-> removed "boolean isChunkMerging()"
			-> removed "boolean isChunkMerging()"
			-> removed "boolean needsChunkMerging()"
			-> moved interface to "snwoflake.api"
			-> removed "Lock lock(Object owner)"
			-> removed "boolean isLocked()"
			-> removed "boolean isStreamable()"
			
		snowflake.api.chunk.IChunkMemory
			-> moved the interface to "snowflake.core.manager"
			
		snowflake.api.chunk
			-> deleted empty package
		
		snowflake.api.configuration.IReadOnlyChannelManagerConfiguration
			-> changed name to "IChannelManagerConfiguration"
			-> moved interface to "snowflake.core.storage"
		
		snowflake.api.configuration.IReadOnlyChunkManagerConfiguration
			-> changed name to "IChunkManagerConfiguration"
			-> moved interface to "snowflake.core.storage"
		
		snowflake.api.configuration.IReadOnlyFlakeManagerConfiguration
			-> changed name to "IFlakeManagerConfiguration"
			-> moved interface to "snowflake.core.storage"
		
		snowflake.api.configuration.IReadOnlyStorageConfiguration
			-> changed name to "IStorageConfiguration"
			-> moved interface to "snowflake.core.storage"
			
		snowflake.api.configuration
			-> deleted empty package
			
		snwoflake.api.flake.IFlakeManager
			-> moved interface to "snwoflake.core.manager"
			
		snowflake.api.flake.DataPointer
			-> removed overflow-check in "long getPositionInStorage()", because it can not overflow
			-> minor change in the text of "String toString()"
			-> minor format changes of the code
			-> moved class to "snowflake.api"
			
		snowflake.api.flake.Lock
			-> deleted class
			
		snowflake.core.flake.FlakeLockManager
			-> deleted class
			
		snowflake.api.flake
			-> deleted empty package
			
		snowflake.api.storage.IManagerAdapter
			-> deleted interface, because it is not useful and the name is irritating
			
		snowflake.core.storage.Storage
			-> no longer implements "IManagerAdapter"
			-> "Stream<IFlake> getFlakes(StreamMode)" is now own method
			-> "Stream<IChunk> getAvailableChunks(StreamMode)" is now own method
			-> "IFlake createFlake()" is now own method
			-> "IFlake getFlake(long)" is now own method
			-> "boolean flakeExists(long identification)" is now own method
			
		snowflake.api.storage.IStorageInformation
			-> moved interface to "snowflake.api"
			
		snowflake.api.storage.StorageException
			-> moved class to "snowflake.api"
			
		snowflake.api.storage
			-> deleted empty package		
		
		
	2016.04.07
		
		snowflake.api.configuration.IReadonlyStorageConfiguration
			-> changed the name to "IReadOnlyStorageConfiguration"
			
		snwoflake.core.manager.ChannelManager
			-> created class
			
		snowflake.core.Channel
			-> created class
			
		snowflake.data
			-> moved all classes (Chunk, ChunkData, and ChunkUtility) to snowflake.core
			-> removed package
			
		snowflake.api.stream
			-> moved all classes (FlakeInputStream and FlakeOutputStream) to snowflake.api
			-> removed package
			
		snowflake.api.GlobalString
			-> added NumberOfChannel("number_of_channel"), Channel("channel"),
				ChannelManagerConfiguration("channel_manager_configuration"), and
				ChannelReturner("channel_returner")
			-> removed IOAccess("io_access")
			-> changed IOAccessGetter("io_access_getter") to ChannelManager("channel_manager")
			
		snowflake.api.configuration.IReadOnlyChannelManagerConfiguration
			-> created interface
			-> added "String getDataFilePath()"
			
		snowflake.api.configuration.IReadOnlyStorageConfiguration
			-> now extends "snowflake.api.configuration.IReadOnlyChannelManagerConfiguration"
			-> removed "String getDataFilePath()"
			
		snowflake.core.Storage.StorageConfiguration
			-> now implements "int getMaximumNumberOfAvailableChannel()"
			-> added "void setMaximumNumberOfAvailableChannel(int)"
			
		snowflake.core.storage.StorageConfigurationElement
			-> added MaximumNumberOfAvailableChannel("maximum_number_of_available_channel")
			
		snowflake.core.manager.IManageChannel
			-> created interface
			
		snowflake.core.storage.IGetIOAccess
			-> removed interface
			
		snowflake.core.storage.Storage
			-> no longer implements "snowflake.core.storage.IGetIOAccess"
			-> added "final ChannelManager channel_manager"
			
		snowflake.core.manager.FlakeManager
			-> changed "FlakeManager(IGetIOAccess)" to "FlakeManager(IManageChannel)"
			-> changed "final IGetIOAccess io_access_getter" to "final ChannelManager channel_manager"
			
		snowflake.core.flake.FlakeStreamManager
			-> changed "FlakeStreamManager(IGetIOAccess)" to "FlakeStreamManager(IGetChannel)"
			-> changed "final IGetIOAccess io_access_getter" to "final IGetChannel channel_getter"
			-> changed "FlakeOutputStream getFlakeOutputStream(Flake)" to
				"FlakeOutputStream getFlakeOutputStream(Flake) throws FileNotFoundException"
			-> changed "FlakeInputStream getFlakeInputStream(Flake)" to
				"FlakeInputStream getFlakeInputStream(Flake) throws FileNotFoundException"
				
		snowflake.core.storage.IRead
			-> no longer implements "java.io.Closeable"
			-> implements snowflake.core.Returnable
				
		snowflake.core.storage.IWrite
			-> no longer implements "java.io.Closeable"
			-> implements snowflake.core.Returnable
			
		snowflake.api.FlakeInputStream
			-> "void close() throws IOException" now returns the read to the ChannelManager
				and remembers that it is closed
			-> changed "FlakeInputStream(Flake, IRead, IRemoveStream)"
				to "FlakeInputStream(Flake, IRead, IRemoveStream, IReturnChannel)"
			-> added "final IReturnChannel channel_returner"
			
		snowflake.api.FlakeOutputStream
			-> "void close() throws IOException" now returns the write to the ChannelManager
			-> changed "FlakeOutputStream(Flake, IWrite, IRemoveStream)"
				to "FlakeOutputStream(Flake, IWrite, IRemoveStream, IReturnChannel)"
			-> added "final IReturnChannel channel_returner"
			
		snowflake.core.manager.IReturnChannel
			-> created interface
	
		
	2016.04.06
	
		snowflake.core.storage.IRead
			-> now extends "java.io.Closeable"
			-> minor modifications in "int read(byte[])"
			
		snowflake.core.storage.IWrite
			-> now extends "java.io.Closeable"
			-> minor modifications in "void write(byte[])"
			
		snowflake.core.flake.FlakeStreamManager
			-> changed "void removeStream(IStateClosure)" to "void removeStream(Closeable)"
			
		snowflake.api.stream.FlakeInputStream
			-> changed "void close()" to "void close() throws IOException"
			-> modified "void close() throws IOException" so that it closes the "read"
			
		snowflake.api.stream.FlakeOutputStream
			-> modified "void close() throws IOException" so that it closes the "write"
			
		snowflake.core.flake.IFlakeStreamManager
			-> changed name of the class to "IRemoveStream"
		
		snowflake.core.storage.IOAccess
			-> no longer implements "java.io.Closeable" explicitly (inherited by "IRead" and "IWrite")
	
	2016.04.04
		
		snowflake.core.storage.Storage
			-> no longer implements "IRead" and "IWrite"
			-> now implements "IGetIOAccess"
			-> removed "RandomAccessFile data_output_file"
			-> changed "data_output_file" to "data_file"
			
		snowflake.core.storage.IOAccess
			-> added class
			
		snowflake.core.storage.IGetIOAccess
			-> added interface
			
		snowflake.api.GlobalString
			-> added IOAccessGetter("io_access_getter") and IOAccess("io_access")
			
		snowflake.core.manager.FlakeManager
			-> removed "IRead read" and "IWrite write"
			-> added "IGetIOAccess io_access_getter"
			
		snowflake.core.flake.FlakeStreamManager
			-> removed "IRead read" and "IWrite write"
			-> added "IGetIOAccess io_access_getter"
			
		snowflake.api.stream.FlakeOutputStream
			-> removed "boolean trim_on_close"
			-> no longer implements "IClose<IOException>"
			-> removed "ClosureState closure_state"
			-> added "boolean closed"
			
		snowflake.api.stream.FlakeInputStream
			-> no longer implements "IClose<IOException>"
			-> removed "ClosureState closure_state"
			-> added "boolean closed"
			
		snowflake.core.flake.IFlakeStreamManager
			-> changed "void removeStream(IStateClosure)" to "void removeStream(Closeable)"		
	
	2016.04.01
	
		snowflake.api.stream.FlakeOutputStream
			-> modified "void close() throws IOException" so that it trims the flake if necessary
			-> added "void trim()", "void ensureCapacity(long)", and "void ensureRemainingCapacity(long)"
		
		snowflake.core.storage.StreamDescription
			-> created class
			
		snowflake.api.GlobalString
			-> added StreamDescription("stream_description") and DataFile("data_file")
			
		snwoflake.api.flake.DataPointer
			-> modified "int hashCode()" so that it now returns the hash-code implemented by Object
			
		snowflake.core.storage.Storage
			-> added "HashMap<DataPointer, StreamDescription> stream_description_map"
			-> added "void writeUnsyncronized(DataPointer, byte) throws IOException"
	
	
	2016.03.14
	
		snowflake.core.manager.ChunkManager
			-> removed "IFlakeModifier flake_modifier"
			-> added "void setInitialIndices(ArrayList<Long>)"
			-> modified "void createAvailableChunk(long)" so that it now tries to pull all available chunks
				from other Managers (like ChunkMergingManager) before actually creating a new chunk
		
		snowflake.core.manager.IFlakeModifier
			-> deleted class
			
		snowflake.api.data.DataTable
			-> added "void addAvailableIndices(ArrayList<Integer>)"
			
		snwoflake.api.flake.IFlakeManager
			-> removed "IFlake declareFlake(long, ChunkManager)"
			
		snowflake.core.manager.FlakeManager
			-> added "IFlake declareFlake(long, ChunkManager, ArrayList<Chunk>)"
			-> "IFlake declareFlake(long, ChunkManager)" now calls 
				"IFlake declareFlake(long, ChunkManager, ArrayList<Chunk>)"
			-> no longer implements " IClose<IOException>" but  " IClose<StorageException>" instead
			-> "void open()" and "void close()" no longer throw "java.io.IOException"
			-> "void open()" now opens all flakes
		
		snowflake.core.flake.Flake
			-> changed "void setFlakeDataManager(FlakeDataManager)"
				to "void setFlakeDataManager(FlakeDataManager, ArrayList<Chunk>)"
		
		snwoflake.core.flake.FlakeDataManager
			-> added "void setInitialChunks(ArrayList<Chunk>)"
			
		sndwoflake.api.configuration.IReadonlyStorageConfiguration
			-> added "long getMaximumStorageSize()"
			
		snowflake.core.storage.StorageConfiguration
			-> implemented "long getMaximumStorageSize()"
			-> added "void setMaximumStorageSize(long)" so that a maximum size of the storage can be set
			
		snowflake.core.storage.StorageConfigurationElement
			-> added MaximumStorageSize("maximum_storage_size")
			
		snowflake.core.storage.Storage
			-> modified "ChunkData allocateSpace(long)" so that it restricts the size of the storage to
				the maximum size
			-> modified "void loadChunks() throws IOException" so that the loading is more efficient due to
				to buffering all Chunks before distributing them to the Managers and Flakes
				
		snowflake.core.manager.ChunkMergingManager
			-> added "Collection<Chunk> removeAll()"
			-> added "boolean isEmpty()"
	
	2016.03.13
	
		snowflake.core.storage.Storage
			-> replaced all occurrences of "write_lock" with "data_output_file"
			-> replaced all occurrences of "read_lock" with "data_input_file"
			-> replaced all occurrences of "event_lock" with "event_lister_list"
			-> removed implementation of "IFlake declareFlake(long)"
			-> removed implementation of "void mergeAvailableChunks(int)"
			-> now opens itself when constructed
			-> removed "void checkForOpen()"
			-> removed all occurrences of "j3l.util.checker.ClosureChecker"
			
		snowflake.api.storage.IManagerAdapter
			-> removed "IFlake declareFlake(long)"
			-> removed "void mergeAvailableChunks(int)"
			
			
		snowflake.core.manager.ChunkManager
			-> removed "void mergeAvailableChunks(int)"
			-> does not longer load chunks on start-up
			
		snowflake.api.storage.IListenerAdapter
			-> deleted interface
	
	
	2016.03.10
		
		snowflake.api.GlobalString
			-> added:
				Flake("flake"),
				PositionInFlake("position_in_flake"),
				FlakeLockManager("flake_lock_manager"),
				Read("read"),
				Write("write"),
				FlakeStreamManager("flake_stream_manager"),
				ChunkMemory("chunk_memory"),
				StartAdress("start_address"),
				Length("length"),
				ChunkTableIndex("chunk_table_index"),
				IndexInFlake("index_in_flake"),
				ChunkData("chunk_data"),
				Buffer("buffer"),
				Chunk("chunk"),
				TableFile("table_file"),
				BinaryData("binary_data"),
				TableIndex("table_index"),
				FlakeDataManager("flake_data_manager"),
				Owner("owner"),
				ChunkManager("chunk_manager"),
				Index("index"),
				FlakeIdentificationStream("flake_identification_stream"),
				ClearChunk("clear_chunk"),
				CleaningTreshhold("cleaning_treshhold"),
				ChunkCollection("chunk_collection"),
				ChunkManagerConfiguration("chunk_manager_configuration"),
				StorageInformation("storage_information"),
				AllocateSpace("allocate_space"),
				FlakeModifier("flake_modifier"),
				ChunkTableFile("chunk_table_file"),
				NumberOfBytes("number_of_bytes"),
				Chunks("chunks"),
				Position("position"),
				Name("name"),
				StorageConfiguration("storage_configuration"),
				ConfigurationFile("configuration_file")
				
	
		changed String-literals in method-calls of j3l.util.check.ArgumentChecker to constants from
			snowflake.api.GlobalString in the following classes:
				-> snowflake.api.flake: Lock
				-> snowflake.api.stream: FlakeInputStream, FlakeOutputStream
				-> snowflake.core.data: Chunk, ChunkData, ChunkUtility, DataTable, TableMember
				-> snowflake.core.flake: Flake, FlakeLockManager, FlakeDataManager, FlakeStreamManager
				-> snowflake.core.manager: FlakeManager, ChunkRecyclingManager, ChunkMergingManager,
											ChunkManager
				-> snowflake.core.storage: IRead, IWrite, StorageConfigurationElement, Storage,
											StorageConfiguration
		
		snowflake.core.data.DataTable
			-> moved to snowflake.api
		
		snowflake.core.data.IBinaryData
			-> moved to snowflake.api
		
		snowflake.core.data.TableMember
			-> moved to snowflake.api
		
		snowflake.core.manager.ChunkMergingManager
			-> changed "Stream<IChunkInformation> getStream(StreamMode)" completely
		
		snowlfake.core.manager.IFlakeModifier
			-> changed "void openFlakes(LongStream )" to "void openFlakes()"
		
		snowlfake.core.manager.FlakeManager
			-> changed "void openFlakes(LongStream )" to "void openFlakes()" and its implementation
		
		snowflake.core.manager.ChunkManager
			-> modified "synchronized void loadChunks() throws IOException" so that chunks which need
				to be cleared are buffered in "recycle_chunk_buffer_list" and are later added to the
				"chunk_recycling_manager" as a bunch
		
		snowflake.api.storage.IStorageInformation
			-> replaced all occurrences of "BigInteger" with "long" and "BigDecimal" with "double"
			-> modified "long getNumberOfChunks()"
			
		snwoflake.core.storage.Storage
			-> replaced all occurrences of "BigInteger" with "long" and "BigDecimal" with "double"
			-> modified "getFreeSpace()", "getUsedSpace()", "getAverageNumberOfChunksPerFlake()",
				"getNumberOfUsedChunks()", "getNumberOfFreeChunks()", "getAverageFlakeSize()",
				"getAverageNumberOfChunksPerFlake()", "getAverageChunkSize()"
	
	
	
	2016.03.07
		
		snowflake.api.GlobalString
			-> new enum
			-> stores common used Strings (e.g. for usage with methods of j3l.util.check.ArgumentChecker)
			
		snowflake.api.flake.DataPointer
			-> changed String-literals in method-calls of j3l.util.check.ArgumentChecker to constants from
				snowflake.api.GlobalString
	
	
	
	2016.03.06
	
		snowflake.api.chunk.IChunkManager
			-> removed "void appendChunk(Flake, long, ChunkAppendingMode)"
			-> "void recycleChunks(Collection<Chunk>)" is now abstract
			-> removed "void recycleChunks(Collection<Chunk>, StreamMode)"
			-> removed "void recycleChunks(Stream<Chunk>)"
			-> removed "void recycleChunks(Chunk[], StreamMode)"
			-> removed "void recycleChunks(Chunk[])"
			
		snowflake.api.chunk.ChunkAppendingMode
			-> deleted class
			
		snowflake.core.manager.ChunkManager
			-> changed "void appendChunk(Flake, long, ChunkAppendingMode)" to 
				"void appendChunk(Flake, long)" and modified method
			-> now implements "void recycleChunks(Collection<Chunk>)"
			-> modified "void recycleChunk(Chunk)"
		
		snowflake.api.chunk.ChunkAttribute
			-> deleted enum
		
		snowflake.api.chunk.ChunkProcessingMode
			-> deleted enum
			
		snowflake.core.data.Chunk
			-> removed "needs_to_be_saved" and "boolean needsToBeSaved()"
			-> removed "boolean containsStoragePosition(long)"
			-> does not implement "boolean containsFlakePosition(long)" from IChunkInformation - 
				instead provides the method as its own member
		
		snowflake.api.chunk.IChunkInformation
			-> removed "boolean needsToBeSaved()"
			-> removed "boolean containsStoragePosition(long)"
			-> removed "boolean containsFlakePosition(long)"
		
		snwoflake.core.flake.FlakdDataManager
			-> modified "recycle"
		
		snowflake.core.manager.ChunkRecyclingManager
			-> no longer implements "IAdd<Chunk>"
			-> added "boolean addAll(Collection<Chunk>)"
			-> modified "boolean add(Chunk)"
			
		snowflake.core.data.DataTable
			-> modified "void trim()", because it deadlocked with "long getAvailableIndex()"
				(both locked "data_table" and "available_index_tree", but in different orders...)
		
	
	2016.02.29
			
		snowflake.core.data.TableMember
			-> deleted class
	
		snowflake.core.data.BinaryDataWrapper
			-> renamed class to "TableMember"
			
		snowflake.core.manager.IndexManager
			-> merged functionality into "snowflake.core.data.DataTable" and deleted the class
			
		snowflake.core.data.DataTable
			-> now fulfills the services of "snowflake.core.manager.IndexManager"
			-> added "long getAvailableIndex()"
			-> added "void addAvailableIndex(long index)"
			-> added "void trim()"
			
		snowflake.core.manager.ChunkManager
			-> removed "IndexManager index_manager" and substituted all its references for "data_table"
	
	
	2016.02.28
	
		snowflake.core.storage.Storage
			-> "int read(DataPointer data_pointer, byte[] buffer, int offset, int length)
			 throws IOException", "byte read(DataPointer data_pointer) throws IOException",
			 "void write(DataPointer data_pointer, byte[] buffer, int offset, int length)
			 throws IOException", and "void write(DataPointer data_pointer, byte b) throws IOException"
			 now increase the position of the data_pointer
			-> "int read(DataPointer data_pointer, byte[] buffer, int offset, int length)
			 throws IOException" completetly rewritten (did not read in as much bytes as stated
			 by length, but as much as were in the chunk the data_pointer pointed currently at)
			
		snowflake.api.stream.FlakeOutputStream
			-> "void write(int b) throws IOException" and "void write(byte[] buffer, int offset, int length)
			 throws IOException" no longer increase the position of the DataPointer
			
		snowflake.api.stream.FlakeInputStream
			-> "int read() throws IOException" and "int read(byte[] buffer, int offset, int length)
			 throws IOException" no longer increase the position of the DataPointer
			
	2016.02.27
	
		snowflake.core.manager.ChunkRecyclingManager
			-> "boolean isEmpty()" now checks both "chunk_recycling_list" and "recycled_chunk_list"
				- fixed a bug (behaved like a leak)
	
		snowflake.core.manager.ChunkManager
			-> removed debug-code
		
		snowflake.core.manager.ChunkMergingManager
			-> changed "BinaryTree<Chunk, Long> chunk_tree" to "ArrayList<Chunk> chunk_list"
			-> removed "boolean contains(Chunk chunk)"
	
	
	2016.02.24
	
		snowflake.core.manager.ChunkManager
			-> modified "void mergeAvailableChunks(int)"
			-> modified "void createAvailableChunk(long)"
			-> modified "void loadChunks() throws IOException"
			-> changed "Collection<Chunk> getAvailableChunks(long number_of_bytes)" to
				"List<Chunk> getAvailableChunks(long number_of_bytes)" + modification
			-> modified "void recycleChunk(Chunk chunk)"
			
		snowflake.core.manager.ChunkRecyclingManager
			-> removed "Stream<Chunk> getStream(StreamMode)" and the implementation of "IStream<Chunk>"
			-> changed "TreeSet<Chunk> chunk_recycling_tree" to "ArrayList<Chunk> chunk_recycling_list"
			-> fixed huge bug in "List<Chunk> removeAll()": the chunks in "chunk_recycling_list"
				where removed instead of the chunks in "recycled_chunks_list"
			
		snowflake.core.data.ChunkData
			-> fixed wrong values in boundary-check (Long.MAX_VALUE instead of Integer.MAX_VALUE)
	
	
	2016.02.23
	
		snowflake.core.data.DataTable
			-> removed "void flush() throws IOException"
			-> edited "addEntry(BinaryDataWrapper<T>)" so that it writes all changes right away
			-> removed "ClosureState closure_state"
			-> removed "open", "close", and "getState()"
			-> no longer implements IClose<IOException>
			
		snowflake.core.data.BinaryDataWrapper
			-> shortened constructor
			
		snowflake.core.manager.ChunkManage
			-> removed "chunk_table_thread" and all occurences
			-> modified "open()" and "close()" ("chunk_table_thread" and "data_table.close()"/"data_table.open()"
				no longer needed) 
	
	
	
	2016.02.22
	
		snowflake.api.configuration.IReadOnlyChunkManagerConfiguration
			-> removed "int getMaximumChunkDataTableSize()"
			
		snowflake.core.storage.StorageConfigurationElement
			-> removed "MaximumChunkDataTableSize("maximum_chunk_data_table_size")"
			
		snowflake.core.storage.StorageConfiguration
			-> removed "void setMaximumChunkDataTableSize(int maximum_chunk_data_table_size)"
				and "int getMaximumChunkDataTableSize()"
			
		snowflake.core.data.DataTable
			-> removed "LinkedList<BinaryDataWrapper<T>> pending_entries_buffer_list" and
				"int max_capacity"
			-> the elements of the table will be written as soon as possible (temporarly buffered in
				"pending_entries_list")
			-> removed "void transferBufferEntries()"
			-> removed "is_flushing" and "boolean isFlushing()"
			-> removed "void flushParallel()"
			
		snowflake.core.manager.ChunkManager
			-> edited the constructor (see above: snowflake.core.data.DataTable)
		
	
	2016.02.18
		
		snowflake.core.manager.ChunkManager
			-> changed "SortedList<Long, Chunk> available_chunk_list" to 
			"BinaryTree<Chunk, Long> available_chunk_tree"
			-> applied all changes so that available_chunk_tree can be used
			-> fixed a bug in mergeChunks(long): the algorithm did not merge all neighboured chunks because
				the min/max criteria were not right (they were both one off)
			
	
	2016.02.15
		
		snowflake.core.manager.ChunkMergingManager
			-> modified most methods for usage of BinaryTree<Chunk> (see 2016.02.14)
		
	
	2016.02.14
	
		snowflake.core.manager.ChunkRecyclingManager
			-> now uses java.util.TreeSet instead of a sorted list
		
		snowflake.core.manager.ChunkMergingManager
			-> changed "SortedList<Long, Chunk> chunk_list" to "BinaryTree<Chunk, Long> chunk_tree"
			-> changed mergeChunks(int) to mergeChunks(long)
	
	
	2016.02.06
	
		snowflake.core.data.ChunkUtility
			-> corrected imports
			
		snowflake.core.flake.Flake
			-> corrected imports
			-> changed all occurrences of ValidationChecker to ArgumentChecker
		
		snowflake.core.manager.FlakeManager
			-> corrected imports		
		
		snowflake.core.manager
		
		
		snowflake.core.manager
		
		
		snowflake.core.manager
	
	
	2016.01.24
	
		snwoflake.core.storage.Storage
			-> fixed HUGE bug: write(DataPointer, byte) and write(DataPointer, byte[], int, int)
				did not check if the number of bytes in the flake satifies the write-operation AND
				write(DataPointer, byte[], int, int) did not seek to a new position when there were more
				bytes to write then there were remaining bytes in the chunk at which the write-operation
				pointed
			-> no more chunk-leaks and -overflows
			
		snowflake.core.data.DataTable
			-> replaced all occurrences of pending_entries_lock with pending_entries_list
			-> replaced all occurrences of pending_entries_buffer_lock with pending_entries_buffer_list
	
	
	2016.01.23
	
		snowflake.core.storage.Storage
			-> modified allocateSpace(long) so that it only calls getAllocatedSpace() once
			
	
	2016.01.22
		
		snowflake.core.data.Chunk
			-> minor modification in the way the constructor-arguments are checked
		
		snowflake.core.manager.ChunkMergingManager
			-> minor structural changes
		
		snowflake.core.manager.ChunkRecyclingManager
			-> add(Chunk) now returns false if the chunk is already part of the chunk_recycling_list
		
	
	2016.01.20
		
		snowflake.core.manager.ChunkRecyclingManager
			-> chunk_recycling_list is now of type j3l.util.collection.SortedList
			-> recycleChunk() now uses the chunk in the middle of the chunk_recycling_list
	
		snowflake.core.storage.IClearChunk
			-> all methods now throw snowflake.api.storage.StorageException
		
		snowflake.core.storage.Storage
			-> clearChunk(Chunk, long, long) now throws snowflake.api.storage.StorageException
		
	
	2016.01.19
		
		snowflake.core.data.ChunkUtility
			-> increased BINARY_CHUNK_SIZE (in 2016.01.19 the structure of the data-sets has been changed)
	
		snwofalke.core.manager.ChunkMergingManager
			-> replaced all occurrences of chunk_lock with chunk_list		
	
		snwofalke.core.manager.ChunkManager
			-> added chunk_recyling_thread and chunk_merging_thread
			-> open now starts chunk_recyling_thread and chunk_merging_thread
			-> close now interrupts chunk_recyling_thread and chunk_merging_thread
			-> removed chunk_file_lock
			-> replaced all occurrences of available_chunk_lock with available_chunk_list
			-> loadChunks() now uses ChunkUtility.configureChunk(Chunk, byte) properly
		
		snowflake.core.storage.Storage
			-> modified allocateSpace(long) (snowflake.core.data.ChunkData constructor has been modified
				in 2016.01.18)
			-> fixed clearChunk(Chunk, long, long): an IndexOutOfBoundsException was thrown when the
				parameter where correct and not when they weren't
				
	
	2016.01.18
		
		snowflake.core.storage.StorageConfigurationElement
			-> added ChunkRecyclingTreshhold
			-> changed MaximumChunkTableSize to MaximumChunkDataTableSize
		
		snowflake.core.storage.StorageConfiguration
			-> implemented getChunkRecyclingTreshhold()
			-> add setChunkRecyclingTreshhold(long)
			-> modified all getter so that the correct snowflake.core.storage.StorageConfigurationElement
				instances are used instead of the hard-coded Strings directly inside the methods
		
		snowflake.api.configuration
			-> added getChunkRecyclingTreshhold()
		
		snwoflake.core.manager.ChunkManager
			-> modified NULL_CHUNK_DATA so that it uses the new constructor (see below)
			-> createAvailableChunk(long) now retrieves all recycled chunks from the ChunkRecyclingManager
				and adds them to the ChunkMergingManager before searching for a suitable Chunk in the chunks
				of the ChunkMergingManager
		
		snowflake.core.data.ChunkUtility
			-> added the static field FLAG_VECTOR_POSITION for 1B flag-vector
			-> changed almost every method (see above)
			-> added createFlagVector(Chunk) and configureChunk(Chunk, byte)
		
		snowflake.core.data.ChunkData
			-> added flag_vector, getFlagVector(), and the argument "flag_vector" in the constructor
			-> modified toString() (see above)
			-> modified hashCode() (now takes the start_address and the length into account)
			-> modified equals(ChunkData): ignores all values but start_address and length for comparison
		
		snowflake.core.storage.ClearChunk
			-> added clearChunk(Chunk, long, long) for partial clearing of a chunk
			-> clearChunk(Chunk) is now default and calls clearChunk(Chunk, long, long)
		
		snowflake.core.storage.Storage
			-> see snowflake.core.storage.ClearChunk
		
		snowflake.core.manager.ChunkRecyclingManager
			-> new class
			-> asynchronous chunk recycling of added chunks (see add(Chunk))
			-> not yet recycled chunks wait until they are cleared in chunk_recycling_list
			-> recycled chunks are stored in the recycled_chunk_list until they 
				are retrieved by getStream(StreamMode)
	
	
	2016.01.07
	
		snowflake.core.manager.ChunkMergingManager
			-> changed add(Chunk) so that false will be returned when the argument is null
			-> mergeChunks(int) now triggers the garbage collection after finishing the merging
			
		snowflake.api.configuration.IReadOnlyChunkManagerConfiguration
			-> removed getChunkManagerIndexConfigurationFilePath()
			
		snowflake.api.configuration.StorageConfiguration
			-> removed setChunkManagerIndexConfigurationFilePath(String)
			-> removed getChunkManagerIndexConfigurationFilePath()
			-> removed ChunkManangerIndexConfigurationFilePath and its references
			
		snowflake.ore.manager.IndexManager
			-> changed completely
			-> now relies on other instances to set/add indices rather than load/save available indices
			-> does not need to be opened/closed (e.g. is no instance of IClose<IOException> any more)
	
	
	
	2016.01.06
	
		snowflake.core.flake.FlakeDataManager
			-> changed the way mergeChunks() used to "count" the size of the chunk_list
			-> removed save() (is not used, nor will it be in the future)
			-> change the name of orderChunks() into arrangeChunks()
			
		snowflake.core.manager.ChunkManager
			-> changed mergeAvailableChunks(int) so that all Chunks in available_chunk_list will be
				transferred to the chunk_merging_manager
			-> added length-check in splitChunk(Chunk, long) for Chunks with a length of 1
				
		snowflake.api.chunk.IChunkManager
			-> changed recycleChunks(Stream<Chunk>) so that it uses method-references
	
	
	
	2015.12.21
	
		snowflake.core.flake.FlakeDataManager
			-> changed addChunk(Chunk) - use chunk_list.isEmpty() instead of chunk_list.size() > 0



	2015.12.18
	
		snowflake.core.manager.ChunkManager
			-> introduced trimToSizeUnsafe() as a private analog to trimToSize() - it does not recycle the 
				chunk, but instead adds it to the list of available chunks - this method should only be used
				with chunks which already have been available, whose which have previously been cleaned up 
				(reduces the runtime of trimToSize() for large chunks dramatically!)
		
		snwoflake.api.flake.DataPointer
			-> added an increasePosition() and a decreasePosition() method (increments/decrements the
				position_in_flake by 1)
			-> renamed setter-methods for position_in_flake (removed the "InFlake")
			
		snowflake.core.stream
			-> moved the package to snowflake.api.stream
			
		snowflake.api.stream
			-> new stream-package (former snowflake.core.stream)
		
		snowflake.api.stream.FlakeInputStream
			-> now changes the position in the flake by the amount of read-in bytes
		
		snowflake.api.stream.FlakeOutputStream
			-> now changes the position in the flake by the amount of written bytes
			
		snowflake.api.flake.IFlake
			-> minor import-change
			
		snowflake.core.flake.Flake
			-> minor import-change
			-> getLength() now returns 0 when the instance is invalid
			
		snowflake.core.flake.FlakeStreamManager
			-> minor import-change
			
		snowflake.core.Chunk
			-> moved the class to the package snowflake.core.data
			
		snowflake.core.data
			-> added the class Chunk (former snowflake.core.Chunk)


	2015.12.17
	
		snowflake.core.manager.ChunkMergingManager
			-> debugged mergeChunks() - it actually works now
			-> added a contains method
			
		snowflake.core.manager.ChunkManager
			-> recycleChunk() now only "recycles" the chunk if the chunk is neither part of the 
			available_chunk_list or the chunk_merging_manager (instead of just plain adding it to the
				available_chunk_list)
				
		snowflake.core.manager.IndexManager
			-> fixed a tiny bug in loadConfiguration() (the position_in_input_buffer has not been reset)


	2015.12.16
		
		snowflake.core.manager.ChunkManager
			-> getAvailableChunks() did not trim chunks to the needed size
			-> getAvailableChunk() & getAvailableChunks() did not remove the chunks from the available_chunks_list,
			but instead kept them and gave them to multiple flake and sometimes multiple times to the same flake
			
		snowflake.core.flake.FlakeDataManager
			-> add() and insertChunk() will check if the certain chunk is already part of the flake and if so will
			throw a SecurityException


