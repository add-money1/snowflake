	
	2016.02.27
	
		snowflake.core.manager.ChunkRecyclingManager
			-> "boolean isEmpty()" now checks both "chunk_recycling_list" and "recycled_chunk_list"
				- fixed a bug (behaved like a leak)
	
		snowflake.core.manager.ChunkManager
			-> removed debug-code
	
	
	2016.02.24
	
		snowflake.core.manager.ChunkManager
			-> modified "void mergeAvailableChunks(int)"
			-> modified "void createAvailableChunk(long)"
			-> modified "void loadChunks() throws IOException"
			-> changed "Collection<Chunk> getAvailableChunks(long number_of_bytes)" to
				"List<Chunk> getAvailableChunks(long number_of_bytes)" + modification
			-> modified "void recycleChunk(Chunk chunk)"
			
		snowflake.core.manager.ChunkRecyclingManager
			-> removed "Stream<Chunk> getStream(StreamMode)" and the implementation of "IStream<Chunk>"
			-> changed "TreeSet<Chunk> chunk_recycling_tree" to "ArrayList<Chunk> chunk_recycling_list"
			-> fixed huge bug in "List<Chunk> removeAll()": the chunks in "chunk_recycling_list"
				where removed instead of the chunks in "recycled_chunks_list"
			
		snowflake.core.data.ChunkData
			-> fixed wrong values in boundary-check (Long.MAX_VALUE instead of Integer.MAX_VALUE)
	
	
	2016.02.23
	
		snowflake.core.data.DataTable
			-> removed "void flush() throws IOException"
			-> edited "addEntry(BinaryDataWrapper<T>)" so that it writes all changes right away
			-> removed "ClosureState closure_state"
			-> removed "open", "close", and "getState()"
			-> no longer implements IClose<IOException>
			
		snowflake.core.data.BinaryDataWrapper
			-> shortened constructor
			
		snowflake.core.manager.ChunkManage
			-> removed "chunk_table_thread" and all occurences
			-> modified "open()" and "close()" ("chunk_table_thread" and "data_table.close()"/"data_table.open()"
				no longer needed) 
	
	
	
	2016.02.22
	
		snowflake.api.configuration.IReadOnlyChunkManagerConfiguration
			-> removed "int getMaximumChunkDataTableSize()"
			
		snowflake.core.storage.StorageConfigurationElement
			-> removed "MaximumChunkDataTableSize("maximum_chunk_data_table_size")"
			
		snowflake.core.storage.StorageConfiguration
			-> removed "void setMaximumChunkDataTableSize(int maximum_chunk_data_table_size)"
				and "int getMaximumChunkDataTableSize()"
			
		snowflake.core.data.DataTable
			-> removed "LinkedList<BinaryDataWrapper<T>> pending_entries_buffer_list" and
				"int max_capacity"
			-> the elements of the table will be written as soon as possible (temporarly buffered in
				"pending_entries_list")
			-> removed "void transferBufferEntries()"
			-> removed "is_flushing" and "boolean isFlushing()"
			-> removed "void flushParallel()"
			
		snowflake.core.manager.ChunkManager
			-> edited the constructor (see above: snowflake.core.data.DataTable)
		
	
	2016.02.18
		
		snowflake.core.manager.ChunkManager
			-> changed "SortedList<Long, Chunk> available_chunk_list" to 
			"BinaryTree<Chunk, Long> available_chunk_tree"
			-> applied all changes so that available_chunk_tree can be used
			-> fixed a bug in mergeChunks(long): the algorithm did not merge all neighboured chunks because
				the min/max criteria were not right (they were both one off)
			
	
	2016.02.15
		
		snowflake.core.manager.ChunkMergingManager
			-> modified most methods for usage of BinaryTree<Chunk> (see 2016.02.14)
		
	
	2016.02.14
	
		snowflake.core.manager.ChunkRecyclingManager
			-> now uses java.util.TreeSet instead of a sorted list
		
		snowflake.core.manager.ChunkMergingManager
			-> changed "SortedList<Long, Chunk> chunk_list" to "BinaryTree<Chunk, Long> chunk_tree"
			-> changed mergeChunks(int) to mergeChunks(long)
	
	
	2016.02.06
	
		snowflake.core.data.ChunkUtility
			-> corrected imports
			
		snowflake.core.flake.Flake
			-> corrected imports
			-> changed all occurrences of ValidationChecker to ArgumentChecker
		
		snowflake.core.manager.FlakeManager
			-> corrected imports		
		
		snowflake.core.manager
		
		
		snowflake.core.manager
		
		
		snowflake.core.manager
	
	
	2016.01.24
	
		snwoflake.core.storage.Storage
			-> fixed HUGE bug: write(DataPointer, byte) and write(DataPointer, byte[], int, int)
				did not check if the number of bytes in the flake satifies the write-operation AND
				write(DataPointer, byte[], int, int) did not seek to a new position when there were more
				bytes to write then there were remaining bytes in the chunk at which the write-operation
				pointed
			-> no more chunk-leaks and -overflows
			
		snowflake.core.data.DataTable
			-> replaced all occurrences of pending_entries_lock with pending_entries_list
			-> replaced all occurrences of pending_entries_buffer_lock with pending_entries_buffer_list
	
	
	2016.01.23
	
		snowflake.core.storage.Storage
			-> modified allocateSpace(long) so that it only calls getAllocatedSpace() once
			
	
	2016.01.22
		
		snowflake.core.data.Chunk
			-> minor modification in the way the constructor-arguments are checked
		
		snowflake.core.manager.ChunkMergingManager
			-> minor structural changes
		
		snowflake.core.manager.ChunkRecyclingManager
			-> add(Chunk) now returns false if the chunk is already part of the chunk_recycling_list
		
	
	2016.01.20
		
		snowflake.core.manager.ChunkRecyclingManager
			-> chunk_recycling_list is now of type j3l.util.collection.SortedList
			-> recycleChunk() now uses the chunk in the middle of the chunk_recycling_list
	
		snowflake.core.storage.IClearChunk
			-> all methods now throw snowflake.api.storage.StorageException
		
		snowflake.core.storage.Storage
			-> clearChunk(Chunk, long, long) now throws snowflake.api.storage.StorageException
		
	
	2016.01.19
		
		snowflake.core.data.ChunkUtility
			-> increased BINARY_CHUNK_SIZE (in 2016.01.19 the structure of the data-sets has been changed)
	
		snwofalke.core.manager.ChunkMergingManager
			-> replaced all occurrences of chunk_lock with chunk_list		
	
		snwofalke.core.manager.ChunkManager
			-> added chunk_recyling_thread and chunk_merging_thread
			-> open now starts chunk_recyling_thread and chunk_merging_thread
			-> close now interrupts chunk_recyling_thread and chunk_merging_thread
			-> removed chunk_file_lock
			-> replaced all occurrences of available_chunk_lock with available_chunk_list
			-> loadChunks() now uses ChunkUtility.configureChunk(Chunk, byte) properly
		
		snowflake.core.storage.Storage
			-> modified allocateSpace(long) (snowflake.core.data.ChunkData constructor has been modified
				in 2016.01.18)
			-> fixed clearChunk(Chunk, long, long): an IndexOutOfBoundsException was thrown when the
				parameter where correct and not when they weren't
				
	
	2016.01.18
		
		snowflake.core.storage.StorageConfigurationElement
			-> added ChunkRecyclingTreshhold
			-> changed MaximumChunkTableSize to MaximumChunkDataTableSize
		
		snowflake.core.storage.StorageConfiguration
			-> implemented getChunkRecyclingTreshhold()
			-> add setChunkRecyclingTreshhold(long)
			-> modified all getter so that the correct snowflake.core.storage.StorageConfigurationElement
				instances are used instead of the hard-coded Strings directly inside the methods
		
		snowflake.api.configuration
			-> added getChunkRecyclingTreshhold()
		
		snwoflake.core.manager.ChunkManager
			-> modified NULL_CHUNK_DATA so that it uses the new constructor (see below)
			-> createAvailableChunk(long) now retrieves all recycled chunks from the ChunkRecyclingManager
				and adds them to the ChunkMergingManager before searching for a suitable Chunk in the chunks
				of the ChunkMergingManager
		
		snowflake.core.data.ChunkUtility
			-> added the static field FLAG_VECTOR_POSITION for 1B flag-vector
			-> changed almost every method (see above)
			-> added createFlagVector(Chunk) and configureChunk(Chunk, byte)
		
		snowflake.core.data.ChunkData
			-> added flag_vector, getFlagVector(), and the argument "flag_vector" in the constructor
			-> modified toString() (see above)
			-> modified hashCode() (now takes the start_address and the length into account)
			-> modified equals(ChunkData): ignores all values but start_address and length for comparison
		
		snowflake.core.storage.ClearChunk
			-> added clearChunk(Chunk, long, long) for partial clearing of a chunk
			-> clearChunk(Chunk) is now default and calls clearChunk(Chunk, long, long)
		
		snowflake.core.storage.Storage
			-> see snowflake.core.storage.ClearChunk
		
		snowflake.core.manager.ChunkRecyclingManager
			-> new class
			-> asynchronous chunk recycling of added chunks (see add(Chunk))
			-> not yet recycled chunks wait until they are cleared in chunk_recycling_list
			-> recycled chunks are stored in the recycled_chunk_list until they 
				are retrieved by getStream(StreamMode)
	
	
	2016.01.07
	
		snowflake.core.manager.ChunkMergingManager
			-> changed add(Chunk) so that false will be returned when the argument is null
			-> mergeChunks(int) now triggers the garbage collection after finishing the merging
			
		snowflake.api.configuration.IReadOnlyChunkManagerConfiguration
			-> removed getChunkManagerIndexConfigurationFilePath()
			
		snowflake.api.configuration.StorageConfiguration
			-> removed setChunkManagerIndexConfigurationFilePath(String)
			-> removed getChunkManagerIndexConfigurationFilePath()
			-> removed ChunkManangerIndexConfigurationFilePath and its references
			
		snowflake.ore.manager.IndexManager
			-> changed completely
			-> now relies on other instances to set/add indices rather than load/save available indices
			-> does not need to be opened/closed (e.g. is no instance of IClose<IOException> any more)
	
	
	
	2016.01.06
	
		snowflake.core.flake.FlakeDataManager
			-> changed the way mergeChunks() used to "count" the size of the chunk_list
			-> removed save() (is not used, nor will it be in the future)
			-> change the name of orderChunks() into arrangeChunks()
			
		snowflake.core.manager.ChunkManager
			-> changed mergeAvailableChunks(int) so that all Chunks in available_chunk_list will be
				transferred to the chunk_merging_manager
			-> added length-check in splitChunk(Chunk, long) for Chunks with a length of 1
				
		snowflake.api.chunk.IChunkManager
			-> changed recycleChunks(Stream<Chunk>) so that it uses method-references
	
	
	
	2015.12.21
	
		snowflake.core.flake.FlakeDataManager
			-> changed addChunk(Chunk) - use chunk_list.isEmpty() instead of chunk_list.size() > 0



	2015.12.18
	
		snowflake.core.manager.ChunkManager
			-> introduced trimToSizeUnsafe() as a private analog to trimToSize() - it does not recycle the 
				chunk, but instead adds it to the list of available chunks - this method should only be used
				with chunks which already have been available, whose which have previously been cleaned up 
				(reduces the runtime of trimToSize() for large chunks dramatically!)
		
		snwoflake.api.flake.DataPointer
			-> added an increasePosition() and a decreasePosition() method (increments/decrements the
				position_in_flake by 1)
			-> renamed setter-methods for position_in_flake (removed the "InFlake")
			
		snowflake.core.stream
			-> moved the package to snowflake.api.stream
			
		snowflake.api.stream
			-> new stream-package (former snowflake.core.stream)
		
		snowflake.api.stream.FlakeInputStream
			-> now changes the position in the flake by the amount of read-in bytes
		
		snowflake.api.stream.FlakeOutputStream
			-> now changes the position in the flake by the amount of written bytes
			
		snowflake.api.flake.IFlake
			-> minor import-change
			
		snowflake.core.flake.Flake
			-> minor import-change
			-> getLength() now returns 0 when the instance is invalid
			
		snowflake.core.flake.FlakeStreamManager
			-> minor import-change
			
		snowflake.core.Chunk
			-> moved the class to the package snowflake.core.data
			
		snowflake.core.data
			-> added the class Chunk (former snowflake.core.Chunk)


	2015.12.17
	
		snowflake.core.manager.ChunkMergingManager
			-> debugged mergeChunks() - it actually works now
			-> added a contains method
			
		snowflake.core.manager.ChunkManager
			-> recycleChunk() now only "recycles" the chunk if the chunk is neither part of the 
			available_chunk_list or the chunk_merging_manager (instead of just plain adding it to the
				available_chunk_list)
				
		snowflake.core.manager.IndexManager
			-> fixed a tiny bug in loadConfiguration() (the position_in_input_buffer has not been reset)


	2015.12.16
		
		snowflake.core.manager.ChunkManager
			-> getAvailableChunks() did not trim chunks to the needed size
			-> getAvailableChunk() & getAvailableChunks() did not remove the chunks from the available_chunks_list,
			but instead kept them and gave them to multiple flake and sometimes multiple times to the same flake
			
		snowflake.core.flake.FlakeDataManager
			-> add() and insertChunk() will check if the certain chunk is already part of the flake and if so will
			throw a SecurityException


