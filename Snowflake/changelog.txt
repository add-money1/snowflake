	
	
	2016.03.10
		
		snowflake.api.GlobalString
			-> added:
				Flake("flake"),
				PositionInFlake("position_in_flake"),
				FlakeLockManager("flake_lock_manager"),
				Read("read"),
				Write("write"),
				FlakeStreamManager("flake_stream_manager"),
				ChunkMemory("chunk_memory"),
				StartAdress("start_address"),
				Length("length"),
				ChunkTableIndex("chunk_table_index"),
				IndexInFlake("index_in_flake"),
				ChunkData("chunk_data"),
				Buffer("buffer"),
				Chunk("chunk"),
				TableFile("table_file"),
				BinaryData("binary_data"),
				TableIndex("table_index"),
				FlakeDataManager("flake_data_manager"),
				Owner("owner"),
				ChunkManager("chunk_manager"),
				Index("index"),
				FlakeIdentificationStream("flake_identification_stream"),
				ClearChunk("clear_chunk"),
				CleaningTreshhold("cleaning_treshhold"),
				ChunkCollection("chunk_collection"),
				ChunkManagerConfiguration("chunk_manager_configuration"),
				StorageInformation("storage_information"),
				AllocateSpace("allocate_space"),
				FlakeModifier("flake_modifier"),
				ChunkTableFile("chunk_table_file"),
				NumberOfBytes("number_of_bytes"),
				Chunks("chunks"),
				Position("position"),
				Name("name"),
				StorageConfiguration("storage_configuration"),
				ConfigurationFile("configuration_file")
				
	
		changed String-literals in method-calls of j3l.util.check.ArgumentChecker to constants from
			snowflake.api.GlobalString in the following classes:
				-> snowflake.api.flake: Lock
				-> snowflake.api.stream: FlakeInputStream, FlakeOutputStream
				-> snowflake.core.data: Chunk, ChunkData, ChunkUtility, DataTable, TableMember
				-> snowflake.core.flake: Flake, FlakeLockManager, FlakeDataManager, FlakeStreamManager
				-> snowflake.core.manager: FlakeManager, ChunkRecyclingManager, ChunkMergingManager,
											ChunkManager
				-> snowflake.core.storage: IRead, IWrite, StorageConfigurationElement, Storage,
											StorageConfiguration
		
		snowflake.core.data.DataTable
			-> moved to snowflake.api
		
		snowflake.core.data.IBinaryData
			-> moved to snowflake.api
		
		snowflake.core.data.TableMember
			-> moved to snowflake.api
		
		snowflake.core.manager.ChunkMergingManager
			-> changed "Stream<IChunkInformation> getStream(StreamMode)" completely
		
		snowlfake.core.manager.IFlakeModifier
			-> changed "void openFlakes(LongStream )" to "void openFlakes()"
		
		snowlfake.core.manager.FlakeManager
			-> changed "void openFlakes(LongStream )" to "void openFlakes()" and its implementation
		
		snowflake.core.manager.ChunkManager
			-> modified "synchronized void loadChunks() throws IOException" so that chunks which need
				to be cleared are buffered in "recycle_chunk_buffer_list" and are later added to the
				"chunk_recycling_manager" as a bunch
		
		snowflake.api.storage.IStorageInformation
			-> replaced all occurrences of "BigInteger" with "long" and "BigDecimal" with "double"
			-> modified "long getNumberOfChunks()"
			
		snwoflake.core.storage.Storage
			-> replaced all occurrences of "BigInteger" with "long" and "BigDecimal" with "double"
			-> modified "getFreeSpace()", "getUsedSpace()", "getAverageNumberOfChunksPerFlake()",
				"getNumberOfUsedChunks()", "getNumberOfFreeChunks()", "getAverageFlakeSize()",
				"getAverageNumberOfChunksPerFlake()", "getAverageChunkSize()"
	
	
	
	2016.03.07
		
		snowflake.api.GlobalString
			-> new enum
			-> stores common used Strings (e.g. for usage with methods of j3l.util.check.ArgumentChecker)
			
		snowflake.api.flake.DataPointer
			-> changed String-literals in method-calls of j3l.util.check.ArgumentChecker to constants from
				snowflake.api.GlobalString
	
	
	
	2016.03.06
	
		snowflake.api.chunk.IChunkManager
			-> removed "void appendChunk(Flake, long, ChunkAppendingMode)"
			-> "void recycleChunks(Collection<Chunk>)" is now abstract
			-> removed "void recycleChunks(Collection<Chunk>, StreamMode)"
			-> removed "void recycleChunks(Stream<Chunk>)"
			-> removed "void recycleChunks(Chunk[], StreamMode)"
			-> removed "void recycleChunks(Chunk[])"
			
		snowflake.api.chunk.ChunkAppendingMode
			-> deleted class
			
		snowflake.core.manager.ChunkManager
			-> changed "void appendChunk(Flake, long, ChunkAppendingMode)" to 
				"void appendChunk(Flake, long)" and modified method
			-> now implements "void recycleChunks(Collection<Chunk>)"
			-> modified "void recycleChunk(Chunk)"
		
		snowflake.api.chunk.ChunkAttribute
			-> deleted enum
		
		snowflake.api.chunk.ChunkProcessingMode
			-> deleted enum
			
		snowflake.core.data.Chunk
			-> removed "needs_to_be_saved" and "boolean needsToBeSaved()"
			-> removed "boolean containsStoragePosition(long)"
			-> does not implement "boolean containsFlakePosition(long)" from IChunkInformation - 
				instead provides the method as its own member
		
		snowflake.api.chunk.IChunkInformation
			-> removed "boolean needsToBeSaved()"
			-> removed "boolean containsStoragePosition(long)"
			-> removed "boolean containsFlakePosition(long)"
		
		snwoflake.core.flake.FlakdDataManager
			-> modified "recycle"
		
		snowflake.core.manager.ChunkRecyclingManager
			-> no longer implements "IAdd<Chunk>"
			-> added "boolean addAll(Collection<Chunk>)"
			-> modified "boolean add(Chunk)"
			
		snowflake.core.data.DataTable
			-> modified "void trim()", because it deadlocked with "long getAvailableIndex()"
				(both locked "data_table" and "available_index_tree", but in different orders...)
		
	
	2016.02.29
			
		snowflake.core.data.TableMember
			-> deleted class
	
		snowflake.core.data.BinaryDataWrapper
			-> renamed class to "TableMember"
			
		snowflake.core.manager.IndexManager
			-> merged functionality into "snowflake.core.data.DataTable" and deleted the class
			
		snowflake.core.data.DataTable
			-> now fulfills the services of "snowflake.core.manager.IndexManager"
			-> added "long getAvailableIndex()"
			-> added "void addAvailableIndex(long index)"
			-> added "void trim()"
			
		snowflake.core.manager.ChunkManager
			-> removed "IndexManager index_manager" and substituted all its references for "data_table"
	
	
	2016.02.28
	
		snowflake.core.storage.Storage
			-> "int read(DataPointer data_pointer, byte[] buffer, int offset, int length)
			 throws IOException", "byte read(DataPointer data_pointer) throws IOException",
			 "void write(DataPointer data_pointer, byte[] buffer, int offset, int length)
			 throws IOException", and "void write(DataPointer data_pointer, byte b) throws IOException"
			 now increase the position of the data_pointer
			-> "int read(DataPointer data_pointer, byte[] buffer, int offset, int length)
			 throws IOException" completetly rewritten (did not read in as much bytes as stated
			 by length, but as much as were in the chunk the data_pointer pointed currently at)
			
		snowflake.api.stream.FlakeOutputStream
			-> "void write(int b) throws IOException" and "void write(byte[] buffer, int offset, int length)
			 throws IOException" no longer increase the position of the DataPointer
			
		snowflake.api.stream.FlakeInputStream
			-> "int read() throws IOException" and "int read(byte[] buffer, int offset, int length)
			 throws IOException" no longer increase the position of the DataPointer
			
	2016.02.27
	
		snowflake.core.manager.ChunkRecyclingManager
			-> "boolean isEmpty()" now checks both "chunk_recycling_list" and "recycled_chunk_list"
				- fixed a bug (behaved like a leak)
	
		snowflake.core.manager.ChunkManager
			-> removed debug-code
		
		snowflake.core.manager.ChunkMergingManager
			-> changed "BinaryTree<Chunk, Long> chunk_tree" to "ArrayList<Chunk> chunk_list"
			-> removed "boolean contains(Chunk chunk)"
	
	
	2016.02.24
	
		snowflake.core.manager.ChunkManager
			-> modified "void mergeAvailableChunks(int)"
			-> modified "void createAvailableChunk(long)"
			-> modified "void loadChunks() throws IOException"
			-> changed "Collection<Chunk> getAvailableChunks(long number_of_bytes)" to
				"List<Chunk> getAvailableChunks(long number_of_bytes)" + modification
			-> modified "void recycleChunk(Chunk chunk)"
			
		snowflake.core.manager.ChunkRecyclingManager
			-> removed "Stream<Chunk> getStream(StreamMode)" and the implementation of "IStream<Chunk>"
			-> changed "TreeSet<Chunk> chunk_recycling_tree" to "ArrayList<Chunk> chunk_recycling_list"
			-> fixed huge bug in "List<Chunk> removeAll()": the chunks in "chunk_recycling_list"
				where removed instead of the chunks in "recycled_chunks_list"
			
		snowflake.core.data.ChunkData
			-> fixed wrong values in boundary-check (Long.MAX_VALUE instead of Integer.MAX_VALUE)
	
	
	2016.02.23
	
		snowflake.core.data.DataTable
			-> removed "void flush() throws IOException"
			-> edited "addEntry(BinaryDataWrapper<T>)" so that it writes all changes right away
			-> removed "ClosureState closure_state"
			-> removed "open", "close", and "getState()"
			-> no longer implements IClose<IOException>
			
		snowflake.core.data.BinaryDataWrapper
			-> shortened constructor
			
		snowflake.core.manager.ChunkManage
			-> removed "chunk_table_thread" and all occurences
			-> modified "open()" and "close()" ("chunk_table_thread" and "data_table.close()"/"data_table.open()"
				no longer needed) 
	
	
	
	2016.02.22
	
		snowflake.api.configuration.IReadOnlyChunkManagerConfiguration
			-> removed "int getMaximumChunkDataTableSize()"
			
		snowflake.core.storage.StorageConfigurationElement
			-> removed "MaximumChunkDataTableSize("maximum_chunk_data_table_size")"
			
		snowflake.core.storage.StorageConfiguration
			-> removed "void setMaximumChunkDataTableSize(int maximum_chunk_data_table_size)"
				and "int getMaximumChunkDataTableSize()"
			
		snowflake.core.data.DataTable
			-> removed "LinkedList<BinaryDataWrapper<T>> pending_entries_buffer_list" and
				"int max_capacity"
			-> the elements of the table will be written as soon as possible (temporarly buffered in
				"pending_entries_list")
			-> removed "void transferBufferEntries()"
			-> removed "is_flushing" and "boolean isFlushing()"
			-> removed "void flushParallel()"
			
		snowflake.core.manager.ChunkManager
			-> edited the constructor (see above: snowflake.core.data.DataTable)
		
	
	2016.02.18
		
		snowflake.core.manager.ChunkManager
			-> changed "SortedList<Long, Chunk> available_chunk_list" to 
			"BinaryTree<Chunk, Long> available_chunk_tree"
			-> applied all changes so that available_chunk_tree can be used
			-> fixed a bug in mergeChunks(long): the algorithm did not merge all neighboured chunks because
				the min/max criteria were not right (they were both one off)
			
	
	2016.02.15
		
		snowflake.core.manager.ChunkMergingManager
			-> modified most methods for usage of BinaryTree<Chunk> (see 2016.02.14)
		
	
	2016.02.14
	
		snowflake.core.manager.ChunkRecyclingManager
			-> now uses java.util.TreeSet instead of a sorted list
		
		snowflake.core.manager.ChunkMergingManager
			-> changed "SortedList<Long, Chunk> chunk_list" to "BinaryTree<Chunk, Long> chunk_tree"
			-> changed mergeChunks(int) to mergeChunks(long)
	
	
	2016.02.06
	
		snowflake.core.data.ChunkUtility
			-> corrected imports
			
		snowflake.core.flake.Flake
			-> corrected imports
			-> changed all occurrences of ValidationChecker to ArgumentChecker
		
		snowflake.core.manager.FlakeManager
			-> corrected imports		
		
		snowflake.core.manager
		
		
		snowflake.core.manager
		
		
		snowflake.core.manager
	
	
	2016.01.24
	
		snwoflake.core.storage.Storage
			-> fixed HUGE bug: write(DataPointer, byte) and write(DataPointer, byte[], int, int)
				did not check if the number of bytes in the flake satifies the write-operation AND
				write(DataPointer, byte[], int, int) did not seek to a new position when there were more
				bytes to write then there were remaining bytes in the chunk at which the write-operation
				pointed
			-> no more chunk-leaks and -overflows
			
		snowflake.core.data.DataTable
			-> replaced all occurrences of pending_entries_lock with pending_entries_list
			-> replaced all occurrences of pending_entries_buffer_lock with pending_entries_buffer_list
	
	
	2016.01.23
	
		snowflake.core.storage.Storage
			-> modified allocateSpace(long) so that it only calls getAllocatedSpace() once
			
	
	2016.01.22
		
		snowflake.core.data.Chunk
			-> minor modification in the way the constructor-arguments are checked
		
		snowflake.core.manager.ChunkMergingManager
			-> minor structural changes
		
		snowflake.core.manager.ChunkRecyclingManager
			-> add(Chunk) now returns false if the chunk is already part of the chunk_recycling_list
		
	
	2016.01.20
		
		snowflake.core.manager.ChunkRecyclingManager
			-> chunk_recycling_list is now of type j3l.util.collection.SortedList
			-> recycleChunk() now uses the chunk in the middle of the chunk_recycling_list
	
		snowflake.core.storage.IClearChunk
			-> all methods now throw snowflake.api.storage.StorageException
		
		snowflake.core.storage.Storage
			-> clearChunk(Chunk, long, long) now throws snowflake.api.storage.StorageException
		
	
	2016.01.19
		
		snowflake.core.data.ChunkUtility
			-> increased BINARY_CHUNK_SIZE (in 2016.01.19 the structure of the data-sets has been changed)
	
		snwofalke.core.manager.ChunkMergingManager
			-> replaced all occurrences of chunk_lock with chunk_list		
	
		snwofalke.core.manager.ChunkManager
			-> added chunk_recyling_thread and chunk_merging_thread
			-> open now starts chunk_recyling_thread and chunk_merging_thread
			-> close now interrupts chunk_recyling_thread and chunk_merging_thread
			-> removed chunk_file_lock
			-> replaced all occurrences of available_chunk_lock with available_chunk_list
			-> loadChunks() now uses ChunkUtility.configureChunk(Chunk, byte) properly
		
		snowflake.core.storage.Storage
			-> modified allocateSpace(long) (snowflake.core.data.ChunkData constructor has been modified
				in 2016.01.18)
			-> fixed clearChunk(Chunk, long, long): an IndexOutOfBoundsException was thrown when the
				parameter where correct and not when they weren't
				
	
	2016.01.18
		
		snowflake.core.storage.StorageConfigurationElement
			-> added ChunkRecyclingTreshhold
			-> changed MaximumChunkTableSize to MaximumChunkDataTableSize
		
		snowflake.core.storage.StorageConfiguration
			-> implemented getChunkRecyclingTreshhold()
			-> add setChunkRecyclingTreshhold(long)
			-> modified all getter so that the correct snowflake.core.storage.StorageConfigurationElement
				instances are used instead of the hard-coded Strings directly inside the methods
		
		snowflake.api.configuration
			-> added getChunkRecyclingTreshhold()
		
		snwoflake.core.manager.ChunkManager
			-> modified NULL_CHUNK_DATA so that it uses the new constructor (see below)
			-> createAvailableChunk(long) now retrieves all recycled chunks from the ChunkRecyclingManager
				and adds them to the ChunkMergingManager before searching for a suitable Chunk in the chunks
				of the ChunkMergingManager
		
		snowflake.core.data.ChunkUtility
			-> added the static field FLAG_VECTOR_POSITION for 1B flag-vector
			-> changed almost every method (see above)
			-> added createFlagVector(Chunk) and configureChunk(Chunk, byte)
		
		snowflake.core.data.ChunkData
			-> added flag_vector, getFlagVector(), and the argument "flag_vector" in the constructor
			-> modified toString() (see above)
			-> modified hashCode() (now takes the start_address and the length into account)
			-> modified equals(ChunkData): ignores all values but start_address and length for comparison
		
		snowflake.core.storage.ClearChunk
			-> added clearChunk(Chunk, long, long) for partial clearing of a chunk
			-> clearChunk(Chunk) is now default and calls clearChunk(Chunk, long, long)
		
		snowflake.core.storage.Storage
			-> see snowflake.core.storage.ClearChunk
		
		snowflake.core.manager.ChunkRecyclingManager
			-> new class
			-> asynchronous chunk recycling of added chunks (see add(Chunk))
			-> not yet recycled chunks wait until they are cleared in chunk_recycling_list
			-> recycled chunks are stored in the recycled_chunk_list until they 
				are retrieved by getStream(StreamMode)
	
	
	2016.01.07
	
		snowflake.core.manager.ChunkMergingManager
			-> changed add(Chunk) so that false will be returned when the argument is null
			-> mergeChunks(int) now triggers the garbage collection after finishing the merging
			
		snowflake.api.configuration.IReadOnlyChunkManagerConfiguration
			-> removed getChunkManagerIndexConfigurationFilePath()
			
		snowflake.api.configuration.StorageConfiguration
			-> removed setChunkManagerIndexConfigurationFilePath(String)
			-> removed getChunkManagerIndexConfigurationFilePath()
			-> removed ChunkManangerIndexConfigurationFilePath and its references
			
		snowflake.ore.manager.IndexManager
			-> changed completely
			-> now relies on other instances to set/add indices rather than load/save available indices
			-> does not need to be opened/closed (e.g. is no instance of IClose<IOException> any more)
	
	
	
	2016.01.06
	
		snowflake.core.flake.FlakeDataManager
			-> changed the way mergeChunks() used to "count" the size of the chunk_list
			-> removed save() (is not used, nor will it be in the future)
			-> change the name of orderChunks() into arrangeChunks()
			
		snowflake.core.manager.ChunkManager
			-> changed mergeAvailableChunks(int) so that all Chunks in available_chunk_list will be
				transferred to the chunk_merging_manager
			-> added length-check in splitChunk(Chunk, long) for Chunks with a length of 1
				
		snowflake.api.chunk.IChunkManager
			-> changed recycleChunks(Stream<Chunk>) so that it uses method-references
	
	
	
	2015.12.21
	
		snowflake.core.flake.FlakeDataManager
			-> changed addChunk(Chunk) - use chunk_list.isEmpty() instead of chunk_list.size() > 0



	2015.12.18
	
		snowflake.core.manager.ChunkManager
			-> introduced trimToSizeUnsafe() as a private analog to trimToSize() - it does not recycle the 
				chunk, but instead adds it to the list of available chunks - this method should only be used
				with chunks which already have been available, whose which have previously been cleaned up 
				(reduces the runtime of trimToSize() for large chunks dramatically!)
		
		snwoflake.api.flake.DataPointer
			-> added an increasePosition() and a decreasePosition() method (increments/decrements the
				position_in_flake by 1)
			-> renamed setter-methods for position_in_flake (removed the "InFlake")
			
		snowflake.core.stream
			-> moved the package to snowflake.api.stream
			
		snowflake.api.stream
			-> new stream-package (former snowflake.core.stream)
		
		snowflake.api.stream.FlakeInputStream
			-> now changes the position in the flake by the amount of read-in bytes
		
		snowflake.api.stream.FlakeOutputStream
			-> now changes the position in the flake by the amount of written bytes
			
		snowflake.api.flake.IFlake
			-> minor import-change
			
		snowflake.core.flake.Flake
			-> minor import-change
			-> getLength() now returns 0 when the instance is invalid
			
		snowflake.core.flake.FlakeStreamManager
			-> minor import-change
			
		snowflake.core.Chunk
			-> moved the class to the package snowflake.core.data
			
		snowflake.core.data
			-> added the class Chunk (former snowflake.core.Chunk)


	2015.12.17
	
		snowflake.core.manager.ChunkMergingManager
			-> debugged mergeChunks() - it actually works now
			-> added a contains method
			
		snowflake.core.manager.ChunkManager
			-> recycleChunk() now only "recycles" the chunk if the chunk is neither part of the 
			available_chunk_list or the chunk_merging_manager (instead of just plain adding it to the
				available_chunk_list)
				
		snowflake.core.manager.IndexManager
			-> fixed a tiny bug in loadConfiguration() (the position_in_input_buffer has not been reset)


	2015.12.16
		
		snowflake.core.manager.ChunkManager
			-> getAvailableChunks() did not trim chunks to the needed size
			-> getAvailableChunk() & getAvailableChunks() did not remove the chunks from the available_chunks_list,
			but instead kept them and gave them to multiple flake and sometimes multiple times to the same flake
			
		snowflake.core.flake.FlakeDataManager
			-> add() and insertChunk() will check if the certain chunk is already part of the flake and if so will
			throw a SecurityException


